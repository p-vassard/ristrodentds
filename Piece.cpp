#include <vector>#include <PA9.h>#include <sstream>#include <iostream>#include "Piece.h"#include "Attaque.h"#include "Define.cpp"//Fonctions communeschar* stringToChar(std::string chaine);int menu(std::vector<std::string> textes, int ecran, int x, int y, int interligne, int defaut, bool retourPossible);int combat(Personnage *joueur, Personnage *ennemi);void boucleAppuie();void nettoieEcran(int ecran);//ConstructeursPiece::Piece() {	posX = 0;	posY = 0;	valeur = 0;	visite = false;	apercu = false;	evenementVisible = false;	creeEvenement(EVT_VIDE);	mur = true;	setEvenementCodeRandom();}Piece::Piece(int x, int y) {	posX = x;	posY = y;	valeur = 0;	visite = false;	apercu = false;	creeEvenement(EVT_VIDE);	evenementVisible = false;	mur = true;}//DestructeurPiece::~Piece() {}/* LABY *///Position de la pièce dans le laby/** *	Renvoit la position en X de la pièce dans le laby */int  Piece::getPosX() {	return this->posX;}/** *	Renvoit la position en Y de la pièce dans le laby */int  Piece::getPosY() {	return this->posY;}//Ouverturesvoid Piece::setSol() {	this->mur = false;}void Piece::setMur() {	this->mur = true;}bool Piece::isSol() {	return !this->mur;	}bool Piece::isMur() {	return this->mur;}//Valeur de la pièce/** *	Donne une valeur à la pièce */void Piece::setValeur(int entree) {	valeur = entree;	return;}/** *	Renvoie la valeur de la pièce */int Piece::getValeur() {	return valeur;}//Pièce visitée/** *	Met la pièce en "visité" (bords evenementVisibles) */void Piece::setVisite(bool valeur) {	this->visite = valeur;	return;}/** *	Renvoie true si la pièce est visitée, false sinon */bool Piece::getVisite() {	return this->visite;}//Pièce aperçue/** *	Met la pièce en "aperçu" (fond evenementVisible) */void Piece::setApercu(bool valeur) {	this->apercu = valeur;	return;}/** *	Renvoie true si la pièce est aperçue, false sinon */bool Piece::getApercu() {	return this->apercu;}/* EVENEMENTS */		//Création des évènements/** *	Créé un évènement dont l'id est passé en paramètres */void Piece::creeEvenement(int id) {	this->evenementType = (int)(id/100);	this->evenementId = id;	this->evenementVisible = true;}/** *	Créé un nouvel évènement de base. Ne peut pas être un évènement de type "sortie de téléport" ou "objet de quête" */std::vector<int> Piece::creeEvenementRandom(int max) {	std::vector<int> retour;	//Le retour sert à créer ensuite des évènements liens (sortie de tp etc.)	int type_event = PA_RandMinMax(0, TYPE_EVT_MAX);	this->evenementVisible = true;	switch(type_event) {		case TYPE_EVT_TELEPORT :			this->evenementType = TYPE_EVT_TELEPORT;			this->evenementId = EVT_TELEPORT;			retour.push_back(EVT_TELEPORT);		//A créer : la sortie de téléporteur		break;	}	return retour;}/** *	Créé un nouvel évènement qui sera un lien avec un autre evenement. Uniquement de type "sortie de téléport" ou "objet de quête". */void Piece::creeEvenementLien(int id, Piece* salleLien) {	this->evenementsAssocies.clear();	this->evenementVisible = true;	this->evenementsAssocies.push_back(salleLien);	if (id == EVT_TELEPORT) {		this->evenementType = TYPE_EVT_TELEPORT;		this->evenementId = EVT_TELEPORT;	}	else if (id == EVT_PORTE || id == EVT_CLEF) {		this->evenementType = TYPE_EVT_PORTE;		this->evenementId = id;	}	setEvenementCodeRandom();	return;}/** *	Ajoute un lien à la pièce */void Piece::setLien(Piece* lien) {	this->evenementsAssocies.push_back(lien);	return;}//Gestion des évènements associés/** *	Renvoit le dernier évènement associé (à utiliser dans le cas où on sait qu'il y a seulement un évènement) */Piece* Piece::getPieceAssociee() {	return this->evenementsAssocies.back();}//Scripts liés à l'id et au type de l'évènement/** *	Définit l'id de l'évènement */int Piece::getIdEvenement() {	return this->evenementId;}/** *	Renvoit le type de l'évènement */int Piece::getTypeEvenement() {	return this->evenementType;}/** *	Retourne le nom de l'objet dans une String, si l'évènement est un objet */std::string Piece::getNomObjet() {	std::string retour = "";	switch(this->evenementId) {		case EVT_CLEF : {			retour = porteGetForme(this->evenementCode) + "clé " + porteGetCouleur(this->evenementCode);			break;		}		case EVT_LEVEL_UP : {			retour = "Sphère de puissance";			break;		}	}	return retour;}/** *	Indique si une pièce est solide (on ne peut pas marcher dessus) *	Exemple : coffres, portes */bool Piece::estSolide() {	return (this->evenementType == TYPE_EVT_COFFRE 		 || this->evenementType == TYPE_EVT_PORTE		 || this->evenementId == EVT_REGEN)		 && this->getEvenementVisible();}/** *	Retourne true si l'évènement s'active automatiquement (ex : combats), false sinon */bool Piece::activationAutomatique() {	return (this->evenementId == EVT_COMBAT)		 && this->getEvenementVisible();}/** *	Retourne true si l'évènement s'active à distance (ex : coffres), false sinon */bool Piece::activationDistance() {	return (this->evenementId == EVT_CLEF		 || this->evenementId == EVT_PORTE		 || this->evenementId == EVT_REGEN		 || this->evenementId == EVT_MODULE)		 && this->getEvenementVisible();}/** *	Retourne true si l'évènement s'active au contact (ex : combats), false sinon */bool Piece::activationContact() {	return !activationDistance();}//Visibilité de l'évènement/** *	Définit si l'évènement est evenementVisible */void Piece::setEvenementVisible(bool evenementVisible) {	this->evenementVisible = evenementVisible;}/** *	Renvoit true si l'évènement est evenementVisible, false sinon */bool Piece::getEvenementVisible() {	return this->evenementVisible;}//Code de l'évènement/** *	Définit le code de l'évènement de la pièce de manière aléatoire et le renvoit */int Piece::setEvenementCodeRandom() {	int code = PA_RandMinMax(0, 65535);	this->evenementCode = code;	return code;}/** *	Définit le code de l'évènement de la pièce */void Piece::setEvenementCode(int code) {	this->evenementCode = code;	return;}/** *	Renvoit le code de l'évènement de la pièce */int Piece::getEvenementCode() {	return this->evenementCode;}//Scripts d'activation/** *	Active un évènement */bool Piece::activeEvenement(Heros* joueur) {	bool valide = false;	if (this->evenementId != EVT_VIDE && this->evenementVisible == true) {		switch(this->evenementId) {			case EVT_SORTIE : {		//002				std::vector<std::string> listeChoix;				listeChoix.push_back("Non");				listeChoix.push_back("Oui");								PA_SetTextTileCol(0, COULEUR_TITRE_EVT);				PA_OutputText(0, 2, 1, "Evènement");				PA_SetTextTileCol(0, COULEUR_TEXTE);				PA_OutputText(0, 2, 3, "Emprunter le passage vers le\nprochain niveau ?");				int choix = menu(listeChoix, 0, 2, 19, 1, 0, false);				if (choix == 0)					valide = false;				else {					valide = true;					this->evenementVisible = false;				}				break;			}			case EVT_LEVEL_UP : {	//003				PA_SetTextTileCol(0, COULEUR_TITRE_EVT);				PA_OutputText(0, 2, 1, "Evènement");				PA_SetTextTileCol(0, COULEUR_TEXTE);				PA_OutputText(0, 2, 3, "Il y a un coffre dans cette\npièce.");								std::vector<std::string> listeChoix;				listeChoix.push_back("Ouvrir le coffre");				listeChoix.push_back("Partir");				int choix = menu(listeChoix, 0, 2, 19, 1, 0, false);				if (choix == 0) {					//On "prend" le level up					this->evenementVisible = false;					valide = true;				}				break;			}			case EVT_COMBAT : {		//201				Personnage* ennemi = new Personnage(1);				//Création de l'ennemi				int resultat = combat(joueur->getPerso(), ennemi);	//Lancement du combat				//int resultat = 1;	//DEBUG, @TODO : delete				delete ennemi;										//Suppression de l'ennemi				this->evenementId = 0;								//Suppression de l'évènement				if (resultat == 1)	//1 si gagné, 2 si perdu					valide = false;									//False n'active pas l'évènement "Game Over"				else					valide = true;				//joueur->getPerso()->setPointsVie(1);	//DEBUG				break;			}			case EVT_MODULE : {		//301				PA_SetTextTileCol(0, COULEUR_TITRE_EVT);				PA_OutputText(0, 2, 1, "Evènement");				PA_SetTextTileCol(0, COULEUR_TEXTE);				PA_OutputText(0, 2, 3, "Il y a un coffre dans cette\npièce.");								std::vector<std::string> listeChoix;				listeChoix.push_back("Ouvrir le coffre");				listeChoix.push_back("Partir");				int choix = menu(listeChoix, 0, 2, 19, 1, 0, false);				if (choix == 0) {					//Création de la nouvelle attaque					Attaque* nouvelleAttaque = new Attaque();					nouvelleAttaque->creeModule(this->evenementCode, joueur->getPerso()->getNiveau());										//Récupération des anciennes attaques					std::vector<Attaque*> attaques = joueur->getPerso()->getAttaquesModifiables();										std::vector<std::string> listeChoixAttaques;					listeChoix.push_back("Annuler");					for(int i = 0 ; i < (int)attaques.size() ; i++)						listeChoixAttaques.push_back(attaques[i]->getNom());										nettoieEcran(0);					PA_SetTextTileCol(0, COULEUR_TITRE_EVT);					PA_OutputText(0, 2, 1, "Evènement");					PA_SetTextTileCol(0, COULEUR_TEXTE);					PA_OutputText(0, 2, 3, "Vous trouvez un module !");					PA_SetTextTileCol(0, COULEUR_OBJET_OBTENU);					PA_OutputText(0, 2, 5, stringToChar(nouvelleAttaque->getDescription()));					PA_SetTextTileCol(0, COULEUR_TEXTE);					PA_OutputText(0, 2, 10, stringToChar("Remplacer quel module ?"));					PA_OutputText(0, 2, 11, stringToChar("Appuyez sur B pour annuler\nl'assimilation."));					int choix = menu(listeChoixAttaques, 0, 2, 19, 1, 0, true);					if (choix != -1) {						joueur->getPerso()->remplaceAttaque(nouvelleAttaque, choix);					}					this->evenementVisible = false;					valide = true;				}								break;			}			case EVT_REGEN : {		//701				PA_SetTextTileCol(0, COULEUR_TITRE_EVT);				PA_OutputText(0, 2, 1, "Evènement");				PA_SetTextTileCol(0, COULEUR_TEXTE);				if (this->evenementCode > 0) {										PA_OutputText(0, 2, 3, "Il y a un regénérateur ici,\nil pourrait fournir des\nsoins.");					if (joueur->getPerso()->getPointsVieMax() != joueur->getPerso()->getPointsVie()) {						std::vector<std::string> listeChoix;						listeChoix.push_back("Utiliser le regénérateur");						listeChoix.push_back("Partir");						int choix = menu(listeChoix, 0, 2, 19, 1, 0, false);						if (choix == 0) {							joueur->getPerso()->setPointsVie(joueur->getPerso()->getPointsVieMax());							this->evenementCode--;							//Jouer son ici						}					}					else						boucleAppuie();				}				else {					PA_OutputText(0, 2, 3, "Il y a un regénérateur ici,\nmais il semble vide.");					boucleAppuie();				}				valide = false;				break;			}			case EVT_PORTE : {		//801				std::vector<std::string> listeChoix;				if (joueur->possedeObjet(this->evenementsAssocies.back()))					listeChoix.push_back("Utiliser la clef");				listeChoix.push_back("Partir");								PA_SetTextTileCol(0, COULEUR_TITRE_EVT);				PA_OutputText(0, 2, 1, "Evènement");				PA_SetTextTileCol(0, COULEUR_TEXTE);				PA_OutputText(0, 2, 3, "Il faut une %sclé %s\npour ouvrir cette porte.", stringToChar(porteGetForme(this->evenementCode)), stringToChar(porteGetCouleur(this->evenementCode)));				int choix = menu(listeChoix, 0, 2, 19, 1, 0, false);				if (choix == 0 && joueur->possedeObjet(this->evenementsAssocies.back())) {					joueur->retireObjet(this->evenementsAssocies.back());					this->evenementId = EVT_VIDE;					this->evenementsAssocies.back()->evenementId = EVT_VIDE;					this->evenementVisible = false;					valide = true;				}							break;			}			case EVT_CLEF : {		//802				PA_SetTextTileCol(0, COULEUR_TITRE_EVT);				PA_OutputText(0, 2, 1, "Evènement");				PA_SetTextTileCol(0, COULEUR_TEXTE);				PA_OutputText(0, 2, 3, "Il y a un coffre dans cette\npièce.");								std::vector<std::string> listeChoix;				listeChoix.push_back("Ouvrir le coffre");				listeChoix.push_back("Partir");				int choix = menu(listeChoix, 0, 2, 19, 1, 0, false);				if (choix == 0) {					//On prend la clef					this->evenementVisible = false;					joueur->ajouteObjet(this);	//Ajout de l'objet à la liste					valide = true;				}				break;			}			default : {				valide = true;			}		}	}	return valide;}//Fonctions internes à la gestion des évènements/** *	Définit la forme de la clef nécessaire à l'ouverture d'une porte, en fonction  du code de l'évènement */std::string Piece::porteGetCouleur(int code) {	std::string couleur;			switch (((int)(code/10))%9) {		case 0 : couleur = "rouge";				break;		case 1 : couleur = "verte";				break;		case 2 : couleur = "jaune";				break;		case 3 : couleur = "marron";			break;		case 4 : couleur = "noire";				break;		case 5 : couleur = "bleue";				break;		case 6 : couleur = "rose";				break;		case 7 : couleur = "orange";			break;		case 8 : couleur = "grise";				break;	}	return couleur;}/** *	Définit la forme de la clef nécessaire à l'ouverture d'une porte, en fonction  du code de l'évènement */std::string Piece::porteGetForme(int code) {	std::string forme;	switch (code%3) {		case 0 : forme = "petite ";			break;		case 1 : forme = "grande ";			break;		case 2 : forme = "";				break;	}	return forme;}